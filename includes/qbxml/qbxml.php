<?php 

foreach (array ('5.0', '6.0', '7.0') as $version) {
  $elements = $element_types = $queries = array();

  $file_header="<?php //\$Id\$

/**
 * @file Quickbooks function reference for QBXML version $version.
 * This file was automatically generated by qbxml.php.  Please see the included
 * README.txt for more information.
 */
";
 
  $vs = str_replace('.', '', $version);
  $types = DOMDocument::load("qbxmltypes$vs.xsd");
  $qbxml = DOMDocument::load("qbxml$vs.xsd");
  $so    = DOMDocument::load("qbxmlso$vs.xsd");
  $ops   = DOMDocument::load("qbxmlops$vs.xsd");

  // Get all of the simple element types (e.g. STRTYPE, INTTYPE, etc. )
  foreach ($types->documentElement->childNodes as $node) {
    if (get_class($node) != 'DOMElement') continue;
    $name = $node->getAttribute('name');

    // TODO this isn't returning much, but do we really need it anyway?
    $element_types[$name] = _get_element($node, $elements);
  }

  // Collect all of the elements and queries from the qbxml files.
  foreach (array('qbxml', 'so', 'ops') as $xmlfile) {
    $xml = $$xmlfile;
    foreach ($xml->documentElement->childNodes as $node) {
      if (get_class($node) != 'DOMElement') continue;

      // Some of these are lists of queries.  Pull these out individually.
      if (substr(_get_name($node), 0, 5) == 'QBXML') {
        foreach ($node->getElementsByTagName('element') as $query) {
          $name = _get_name($query);
          $type = $query->getAttribute('type');
          if (!isset($elements[$type])) $elements[$type] = array();
          $queries[$name] =& $elements[$type];
        }
      }

      // This is a normal element (elements, macros, aggregates, requests...)
      else {
        _get_element($node, $elements, TRUE);
      }
    }
  }

  // Write the resulting arrays to a file.
  $output = $file_header ."\nfunction _qb_qbxml_types() {\n";
  $output .= '  return '. var_export($element_types, TRUE) ."; ";
  $output .= "}\n";

  $output .= "\nfunction _qb_qbxml_queries() {\n";
  $output .= '  return '. var_export($queries, TRUE) ."; ";
  $output .= "}\n";

  file_put_contents('qbxml.'. $version .'.inc', $output);
}

function _get_xml($xml, &$elements, &$queries) {
  foreach ($xml->documentElement->childNodes as $node) {
    _get_element($node, TRUE);
  }
}

function _get_name($node) {
  $name = $node->getAttribute('name');
  if (!$name) $name = $node->getAttribute('ref');
  return $name;
}

function _get_element($node, &$elements, $save = NULL) {
  global $element_types;
  $e = $group = array();

  if (get_class($node) != 'DOMElement') return;

  $name = _get_name($node);

  $min_occurs = $node->getAttribute('minOccurs');
  if ( $min_occurs !== '') {
    $e['min_occurs'] = $min_occurs;
  }

  $max_occurs = $node->getAttribute('maxOccurs');
  if ( $max_occurs !== '' ) {
    $e['max_occurs'] = $max_occurs;
  }

  $default = $node->getAttribute('default');
  if ( $default !== '' ) {
    $e['default'] = $default;
  }

  // If it contains a sequence of items, list its children.
  elseif (in_array($node->childNodes->item(1)->nodeName, array('xsd:choice', 'xsd:sequence', 'xsd:complexType'))) {
    foreach ($node->getElementsByTagName('sequence') as $sequence) {
      foreach ($sequence->childNodes as $element) {
        if (get_class($element) != 'DOMElement') continue;
        // If it is a group field, we treat it as if it were a plain (non ref) 
        // xsd:element, we do a ref lookup
        if ($element->nodeName == 'xsd:group' && 
            !$element->hasChildNodes()) {
          $e =& _get_element($element, $elements);
        }
        else {
          $group[_get_name($element)] = _get_element($element, $elements);
        } 
      }
    }
    foreach ($node->getElementsByTagName('choice') as $choice) {
		  foreach($choice->childNodes as $element) {
			  if (get_class($element) != 'DOMElement') continue;
			  $group['choice'][_get_name($element)] = _get_element($element, $elements);
			}
		}
    foreach ($node->getElementsByTagName('complexType') as $sequence) {
      foreach ($sequence->childNodes as $element) {
        if (get_class($element) != 'DOMElement') continue;
        $group[_get_name($element)] = _get_element($element, $elements);
      }
    }
  }

  // Reference to another item.
  elseif ($node->getAttribute('ref')) {
    if ($name == 'DataExtRet') {
      $e = array_merge($e, array('DataExtName' => array('type'=>'STRTYPE'),
        'DataExtType' => array('type' => 'STRTYPE'),
        'DataExtValue' => array('type' => 'STRTYPE')
      ));
    } else {
      if (!isset($elements[$name])) $elements[$name] = array();
      $e =& $elements[$name];
    }
  }

  elseif ( $type = $node->getAttribute('type') ) {
    // It's a complex type, e.g. a query type reference.
    if (!isset($element_types[$type])) {
      if (!isset($elements[$type])) $elements[$type] = array();
      $elements[$name] =& $elements[$type];

      // Keep track of queries in a list.
      if (substr($name, -2) == 'Rq') $queries[] = $name;
    }

    // It's a simple type, e.g. STRTYPE, DATETIMETYPE, etc.
    else {
      $e['type'] = $type;
    }
  }

  // It's a simple type with some extra data.
  if ($node->childNodes->item(1)->nodeName == 'xsd:simpleType') {
    foreach ($node->getElementsByTagName('restriction') as $r) {
      $e['type'] = $r->getAttribute('base');
      switch ($e['type']) {
        case 'ENUMTYPE':
          $e['options'] = array();
          foreach ($node->getElementsByTagName('enumeration') as $v) {
            $e['options'][] = $v->getAttribute('value');
          }
          break;
  
        case 'STRTYPE':
          foreach ($node->getElementsByTagName('maxLength') as $v) {
            $e['max_length'] = $v->getAttribute('value');
          }
          break;
  
        case 'INTTYPE':
          foreach ($node->getElementsByTagName('minInclusive') as $v) {
            $e['min'] = (int) $v->getAttribute('value');
          }
          foreach ($node->getElementsByTagName('maxInclusive') as $v) {
            $e['max'] = (int) $v->getAttribute('value');
          }
          break;
      }
    }
  }

  if (array_key_exists('', $group)) {
    //Move all of them into $e
    foreach($group[''] as $val){
      $e[] = $val;
    }
    unset($group['']);
  }

  $e = array_merge($e, $group);
  if ($save) $elements[$name] = $e;
  return $e;
}
